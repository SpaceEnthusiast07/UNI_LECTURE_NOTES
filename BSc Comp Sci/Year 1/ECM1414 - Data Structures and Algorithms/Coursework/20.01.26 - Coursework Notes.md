[Coursework Specification](https://ele.exeter.ac.uk/pluginfile.php/5547597/mod_resource/content/2/Coursework%20Description%20Final.pdf)

For each numbered section in the specification, I will write some notes/thoughts on each.


#### 1. Introduction
 - Apply fundamental concepts of algorithms and data structures.
 - Emphasises correctness and algorithmic efficiency.
 - Compare brute force approach with a more sophisticated approach.


#### 3. Scenario Description
 - I am part of a student society committee.
 - We need to plan a special event weekend.
 - We have received funding and have a certain amount of time.
 - We cannot do everything we would like.
 - We have a list of activities.
 - Each activity has a time requirement, cost and estimated enjoyment value.
 - We need to implement an *Event Planner* that helps the committee decide which activities to include.
 - The goal is to maximise the enjoyment value while staying in the *constraints of time and cost*.
 - You cannot partially do an activity nor repeat the same activity.
 - *The challenge* is to find which *best combination of activities* fits within the time and/or cost *constraints*.


#### 4. Formal Problem Specification
##### 4.1 Input Space
 - We are given $n$ activities.
 - Each activity has the following attributes:
	 - **Name**: A short descriptive name or id.
	 - **Time (Hours)**: A positive int representing the time required for the activity.
	 - **Cost**: A positive int representing the cost of the activity.
	 - **Enjoyment Value**: A positive value representing the estimated enjoyment/benefit the society members receive.
 - You also have some constraints:
	 - **Max Available Time (T)**: Total num of hours for activity over weekend.
	 - **Max Budget (B)**: The total amount of money to spend.
 - For the core coursework, *only one constraint* can be adhered to, an optional task is to adhere to both.


##### 4.2 Constraints
 - You *cannot repeat an activity*.
 - For time (T), the sum of each time required must not exceed T.
 - For budget (B), the sum of each activity cost must not exceed B.
 - You must select a *subset* of the available activities.


##### 4.3 Objective
 - Goal: *Maximise the enjoyment* value, whilst adhering to the chosen constraint.


##### 4.4 Algorithmic Approaches
 - We are required to implement two approaches:
 - **Brute Force** (Exhaustive Search):
	 - Generate and evaluate all possible subsets of activities.
	 - There are $2^n$ subsets for $n$ activities.
		 - E.g. $n=10, \; 2^{10} = 1024 \; \text{subsets}$.
	 - For each subset, check whether it satisfies the chosen constraint, if so, calc its enjoyment value.
	 - Keep track of the set of activities with the highest enjoyment value that satisfy the constraint.
 - **Improved Algorithm** (Dynamic Programming):
	 - Use dynamic programming principles.
	 - Build up solutions to larger problems using solutions to smaller problems.
	 - Avoid redundant computation.
	 - Should produce same optimal solution as brute force.
	 - Group is expected to carry out *independent research* on dynamic programming.
 - Documentation:
	 - *Explain* both *algorithms* clearly.
	 - Provide *pseudocode*.
	 - *Compare performance* of inputs of different sizes.


#### 5. Input File Format
 - Program read config from plain text file - `.txt`!
 - Not any other format.
##### 5.1 General Description
 - **Line 1**: Integer $n$ = number of activities in file.
 - **Line 2**: Two integers separated by a space. $T$ = max available time in hours. $B$ = max budget in pounds.
 - **Lines 3 to (n+2)**: Each line represents an activity, in the following format:
	 - **Activity Name**: A single word or hyphen-separated phrase with no spaces, e.g. Board-Games or Museum-Trip.
	 - **Time Required**: A positive integer in hours.
	 - **Cost**: A positive integer in pounds.
	 - **Enjoyment Value**: A positive integer.
	 - These four fields are separated by a single space.
 - Assumptions:
	 - All integers are positive.
	 - Activity names contain no spaces, either hyphens or underscores.
	 - File format is strictly adhered to.
	 - There is at least one activity, $n\geq {1}$.
	 - It is possible that no feasible solution exists if all activities exceed the constraints, therefore your program should handle this.


##### 5.2 -> 5.4 Examples
 - These next 3 subsections provide three example input files, with a description and expected behaviour.


#### 6. Program Output
##### 6.2 Example Output
```
========================================
EVENT PLANNER - RESULTS
========================================

Input File: input_small.txt
Available Time: 10 hours
Available Budget: £200

--- BRUTE FORCE ALGORITHM ---
Selected Activities:
 - Game-Night (3 hours, £80, enjoyment 120)
 - Pizza-Workshop (2 hours, £60, enjoyment 100)
 - Hiking (5 hours, £30, enjoyment 140)
Total Enjoyment: 360
Total Time Used: 10 hours
Total Cost: £170
Execution Time: 0.002 seconds

--- DYNAMIC PROGRAMMING ALGORITHM ---
Selected Activities:
 - Game-Night (3 hours, £80, enjoyment 120)
 - Pizza-Workshop (2 hours, £60, enjoyment 100)
 - Hiking (5 hours, £30, enjoyment 140)
Total Enjoyment: 360
Total Time Used: 10 hours
Total Cost: £170
Execution Time: 0.001 seconds

========================================
```
 - Is it recommended that your *output* is the *same*!


#### 7. Program Requirements
##### 7.1 Baseline (Brute-Force) Algorithm
 - *Process*:
	 - Generate all possible subsets.
	 - For each subset, check whether it satisfies the constraints, time and/or budget.
	 - For each feasible subset, compute the enjoyment value.
	 - Keep track of the best feasible solution, one with largest enjoyment value.
	 - Return the optimal solution, i.e. the set of activities, total enjoyment, time used and cost.
 - *Implementation*:
	 - Use recursive enumeration.
	 - Use Python's `itertools.combinations` (or similar).
 - *Documentation*:
	 - Explain how this algorithm generates and evaluates all possible subsets.
	 - Include pseudocode.
	 - Discuss why the time complexity is exponential.


##### 7.2 Improved Algorithm (Dynamic Programming)
 - You need to implement at least one more efficient algorithm based on dynamic programming principles.
 - This algorithm should:
	 - Systematically build up solutions to the problem by solving smaller subproblems.
	 - Avoid redundant computation, use memoisation or top-down dynamic programming.
	 - Produce the same optimal solution.
 - Guidance:
	 - 









