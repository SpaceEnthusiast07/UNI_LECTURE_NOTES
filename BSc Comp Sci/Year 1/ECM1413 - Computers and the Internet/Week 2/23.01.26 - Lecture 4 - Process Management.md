[Slides](https://ele.exeter.ac.uk/pluginfile.php/5558372/mod_resource/content/2/ECM1413_25_26_Lecture_04_Process_Management.pdf)


##### Contents
 - [[#Programs vs. Processes]]
 - [[#The Process Lifecycle]]
 - [[#Process Control Block (PCB)]]
 - [[#Context Switching]]
 - [[#Process Address Space]]
 - [[#Process Spawning (Linux)]]


##### Programs vs. Processes
 - A ***program*** is a set of *passive* instructions for performing a specific task (like an `.exe` file) and is stored on secondary storage (non-volatile).
 - On the other hand, a ***process*** is an *active program in execution* and requires CPU resources, main memory and I/O resources.
 - Example:
	 - When you see Google Chrome sitting in your applications folder, that is a *program*, it is static and inactive.
	 - Then, when you double click the Google Chrome file, it opens a browser window.
	 - This is now an active instance of the Google Chrome program, a *process*.
 - By organising computer tasks into processes we achieve both *modularity* and *improved performance*.


##### The Process Lifecycle
 - A process moves through *different states* from the moment it is *created* until it is *finishes*: ![[Pasted image 20260123105524.png]]
 1. ***New***: The process is being *created*.
 2. ***Ready***: The process is *waiting to be assigned to a processor*.
 3. ***Running***: Instructions are now being *executed*.
 4. ***Waiting***: The process is waiting for some *event to occur* (like a file finishing a download), some *I/O operation to complete*.
 5. ***Terminated***: The process has *finished execution* or is *terminated by some other factor* (like the user clicking the close button or an error occurs).
 - *Keywords*:
	 - ***Admitted***: This is the action of moving a process from "*New*" to "*Ready*".
	 - ***Dispatch***: Going from "*Ready*" to "*Running*" state.
	 - ***Pause***: From "*Running*" to "*Ready*".
	 - ***I/O Begin***: From "*Running*" to "*Waiting*".
	 - ***I/O End***: From "*Waiting*" to "*Ready*".
	 - ***Exit***: From "*Running*" to "*Terminated*".


##### Process Control Block (PCB)
 - The Operating System uses a "file" called a ***Process Control Block (PCB)***, which is *stored in main memory*, to *keep track* of the information about *each process*.
 - It acts like an *identity card* for a process.
 - This file contains:
	 - ***Process Number***: A unique ID for that particular process.
	 - ***Process State***: Whether it is currently running, waiting, etc.
	 - ***Process Address Space***: Where its data is located in main memory.
	 - ***I/O Information***: Which files or hardware (like a printer) it is currently using.


##### Context Switching
 - Computers often run many processes at once by switching between them very quickly.
 - *What Happens?*: To switch from Process 1 to Process 2, the system must:
	 - *Pause* process 1, i.e. change the process state to "*Ready*".
	 - Save the *context* of process 1.
	 - Load the *context* of process 2.
	 - Dispatch process 2, i.e. change the process state to "*Running*".
 - *The Trade Off*: Context switches are "pure overhead", meaning that the CPU isn't doing any "real" work while switching, it's just moving data.
	 - Too Few Switches: The computer feels laggy or unresponsive.
	 - Too Many Switches: The computer becomes inefficient because it's spending too much time switching instead of working.
 - The time it takes to switch contexts (processes) depends on several factors, such as the number of registers that need to be copied.
 - Therefore, the process scheduling algorithm needs to find a middle ground, making the computer feel responsive but not wasting too much time switching contexts.![[Pasted image 20260124191813.png]]


##### Process Address Space
 - Every process has its own private area of memory, divided into four sections: ![[Pasted image 20260124191939.png]]
 - ***Text***: Contains the actual program code.
 - ***Data***: Stores static variables (data that doesn't change size).
	 - I.e. if a variable doesn't change data type during the execution of the program, then that variable is stored here.
 - ***Stack***: Stores temporary data, like function parameters and local variables. ![[Pasted image 20260124192147.png]]
	 - When you call a function, data is "pushed" to the stack, then when you exit the function, the data is "popped" off the stack.
	 - It grows *downwards* towards the heap.
 - ***Heap***: Used for data that needs a flexible amount of memory or needs to persist beyond the scope of a single function. ![[Pasted image 20260124192204.png]]
	 - Blocks of memory are allocated and removed in an arbitrary (random) order.
	 - It grows *upwards* towards the stack.


##### Process Spawning (Linux)
 - ***Process spawning*** is the mechanism by which one process (the "Parent") creates a new process (the "Child").
 - In Linux, this happens through a specific sequence of *four system calls*.
 - `fork` ***(The Copy)***:
	 - The `fork` command is how a process duplicates itself, i.e. the *process control block*.
	 - *What it does*: It creates a child process that is an exact copy of the parent's "address space" 9its memory, data, and code).
	 - *The Difference*: Even though they look identical, they have unique ***Process IDs (PIDs)***.
	 - *How they know who is who*: The `fork` call returns a value to both. The child receives a `0`, while the parent receives the child's new PID.
 - `exec` ***(The Transformation)***:
	 - Usually, you do not want two identical processes running the same thing. `exec` is used to change the child into a different program.
	 - *What it does*: It runs an executable file that overwrites the current process's memory with a brand new program.
	 - *The Result*: This allows the parent and child to "go their separate ways" - the parent keeps doing its original task, while the child starts a new one.
 - `wait` ***(The Pause)***:
	 - Sometimes the parent needs to know the result of the child's work before it can continue.
	 - *What it does*: The parent's process state is changed to "*Waiting*".
	 - *When it ends*: The parent process stays paused until the child process has finished its execution.
		 - *Example*: When you tell a program to "Install", the installer (*parent process*) might wait for a specific background script (*child process*) to finish moving files before it shows the "Success" screen.
 - `exit` ***(The Completion)***:
	 - This is how a process tells the operating system it is finished its execution.
	 - *What it does*: The child process issues the `exit` call when it is done with its task.
	 - The Result: This signals the operating system to clean up the child's resources and tells the parent process it can finally resume, and changes it's process state to "Ready".


##### Interprocess Communication (IPC)
 - Processes often need to talk to each other.
 - There are two main ways to do this:
 - ***Shared Memory***: Two processes both look at the *same agreed area of memory*. It is very fast and efficient for large amounts of data. ![[Pasted image 20260124195100.png]]
	 - This method requires only one system call to set up the shared memory space.
 - ***Message Passing***: Processes send and receive messages from a *"mailbox"*. This is better for smaller bits of information and is easier to manage. ![[Pasted image 20260124195201.png]]
	 - This requires a system call for every message that needs to be sent.
 - Graph comparing the computational complexity for message passing and shared memory: ![[Pasted image 20260124195613.png]]







