[Slides](https://ele.exeter.ac.uk/pluginfile.php/5558371/mod_resource/content/2/ECM1413_25_26_Lecture_03_Input_Output_Management.pdf)


##### Contents
 - [[#I/O Devices]]
 - [[#I/O Controllers]]
 - [[#I/O Addressing]]
 - [[#Communicating with I/O Devices]]
 - [[#System Calls]]


##### I/O Devices
 - ***I/O devices*** enable computers to *receive or output information* to humans or devices.
 - Such devices include:
	 - Human Interface devices, e.g. displays, printers, speakers, keyboard and mice, touch screen (I+O).
	 - Storage devices, e.g. HDD, SSD, USB Stick, CD, Floppy Disk.
	 - Transmission devices, e.g. Network Interface Cards


##### I/O Controllers
 - Each I/O device is operated using ***dedicated controllers*** (embedded processors). ![[Pasted image 20260119143638.png]]
 - The CPU communicates with the controller by reading and writing to the ***controller's registers***.
 - The ***Data In*** register holds the data *coming from the I/O device* to the computer, such as the keys pressed on a keyboard.
 - The ***Data Out*** register holds the data *coming from the computer* to the I/O device, such as the pixels to display on a monitor.
 - The ***Status*** register holds information about the *state of the I/O device*, such as "some new keys have been pressed on the keyboard".
 - The ***Control*** register allows the CPU to give the I/O device instructions, such as display these pixels or save this file.


##### I/O Addressing
 - The CPU accesses these I/O device registers using two main methods:
 - ***Port-mapped I/O***: Uses *special*, dedicated instructions.
 - ***Memory-mapped I/O***: Uses *standard* memory instructions, mapping the registers into the same address space as the main memory. This is the more common method today as it simplifies the design of the CPU.


##### Communicating with I/O Devices
 - There is three primary methods for managing the transfer of data between the CPU and I/O controllers.
 - ***Polling***:
	 - The CPU *periodically checks the controller's status register* to see if it is busy (e.g. finished saving a file) or if there is any new data in the data in register (e.g. new keys pressed on the keyboard).
	 - When the device is ready the CPU writes to the data out register and then signals the controller via the control register or reads data from the data in.
	 - This method is only efficient if the device is very fast, the I/O rate is high or the CPU has nothing else to do.
 - ***Interrupts***:
	 - The CPU monitors an ***interrupt-request line***. When a device sends a signal, the CPU *pauses its current process to handle the request*.
	 - Unlike polling, where the CPU must check each device individually, interrupts allow an ***Interrupt Controller (IC)*** to *monitor multiple devices* simultaneously and *prioritise* them.
 - ***Direct Memory Access (DMA)***:
	 - For large data transfers, the CPU *offloads the work to a DMA controller*.
	 - The CPU writes a ***command block*** into main memory, specifying the data's source and destination.
	 - The *DMA controller* then handles *multiple transfers independently* and sends a *single interrupt to the CPU* only when the *entire task is finished*.


##### System Calls
 - A ***system call*** is a *request of a kernel service*.
 - Instructions are either executed in user mode (application programs; plain instructions) or kernel mode (system functions; privileged instructions).
 - There are three types of I/O devices based on how the OS interacts with them using system calls:
 - ***Character I/O***
	 - Low volume devices where the data must be processed in the exact order it arrives in.
	 - E.g. keyboards, mice, microphones.
 - ***Block I/O***
	 - High volume mass storage that transfers data in large "blocks".
	 - Includes memory-mapped files to reduce mode switches.
	 - E.g. HDD and SSDs.
 - ***Network I/O***
	 - Uses "sockets" to send/receive packets.
	 - Unlike others, it must routinely handle errors like missing packets.
	 - E.g. network cards.





