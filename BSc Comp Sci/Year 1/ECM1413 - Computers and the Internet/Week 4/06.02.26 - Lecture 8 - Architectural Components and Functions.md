[Slides](https://ele.exeter.ac.uk/pluginfile.php/5581319/mod_resource/content/1/Lecture%208%20Updated.pdf)


##### Contents
 - [[#What is Pipelining?]]
 - [[#Comparing Processor Types]]
 - [[#The Five Stages of the Pipeline]]
 - [[#Pipeline Hazards]]
 - [[#Solutions to Hazards]]
 - [[#Summary]]


##### What is Pipelining?
- **Pipelining** is a technique where the *execution* of *multiple instructions* is *overlapped*.
- It *takes advantage* of the fact that *different parts* of the *instruction execution* process use *different hardware recourses*.
- **Key Advantage**: It increases *throughput*, which is the *number of instructions completed per unit of time*.
- **Important Distinction**: Pipelining *does not reduce the "latency"* (the time it takes for one specific instruction to finish); it only *helps the computer finish a large batch of instructions faster*.


##### Comparing Processor Types
 - **Single-Cycle Machines**
	 - Every instruction takes *exactly one long clock cycle* to finish.
	 - The *cycle* must be *long enough for the slowest possible instruction*.
 - **Multi-Cycle Machines**
	 - Each instruction is *broken down into smaller steps*.
	 - This allows for a *shorter clock cycle*, but each *instruction* now takes *multiple cycles to complete*.
 - **Pipelined Machine**
	 - These also break instructions into steps but start the next instruction before the previous one is finished.
	 - In an ideal scenario, a pipelined processor completes one instruction every single cycle (CPI = 1).
 - Example for 100 instructions:
	 - Single-Cycle: 4500ns.
	 - Multi-Cycle: 4600ns.
	 - Ideal Pipelined: 1040ns.


##### The Five Stages of the Pipeline
Modern processors typically break an instruction into these five steps:
1. **Instruction Fetch (IF)**: Retrieve the instruction from memory and update the Program Counter (PC).
2. **Instruction Decode (ID)**: Figure out what the instruction needs to do and read the necessary data from registers.
3. **Execution (EX)**: Use the ALU (Arithmetic Logic Unit) to perform calculations.
4. **Memory Access (MEM)**: Read from or write to the system memory (if the instruction is a LOAD or STORE operation).
5. **Write Back (WB)**: Write the final result back into the register file.


##### Pipeline Hazards
**Hazards** are problems that *prevent the next instruction* from *executing* in its *designated clock cycle*.
There are three main types:
 - **Structural Hazards**
	 - These happen when the *hardware cannot support two different instructions at the same time*.
	 - E.g. if *two instructions* both need to *access memory* at the *exact same moment*.
 - **Data Hazards**
	 - These occur when an *instruction depends on the result* of a *previous instruction* that hasn't finished yet.
 - **Control Hazards**
	 - These arise from "branch" instructions (like `if` statements) that *change which instruction should be executed next*.
	 - This makes it hard for the pipeline to "guess" the next instruction to fetch.


##### Solutions to Hazards
To keep the processor running smoothly, several techniques are used:
 - **Forwarding (Bypassing)**
	 - This allows a *result* to be *sent directly* from the *hardware unit that produced it* (like the ALU) *to the unit that needs it*.
	 - It *avoids* needing to *write and read* the *result from a register*.
	 - I.e. its like me passing a piece of paper to a friend directly without putting it down on the table ü§£üòÅ.
 - **Pipeline Stalls (Bubbles)**
	 - If the hazard cannot be solved by forwarding, the processor must "*stall*".
	 - This means inserting a "NOP" (No Operation) or "bubble", *pausing the newer instructions until the hazard is cleared*.
	 - I.e. the processor *delays* the *processing* of any *other tasks until* the *hazard is resolved*.


##### Summary
 - The potential speed up is equal to the number of pipeline stages.
 - The overall speed is limited to the slowest stage in the pipeline.
 - Unbalanced stage lengths or the time it takes to "fill" and "drain" the pipeline will reduce its efficiency.








