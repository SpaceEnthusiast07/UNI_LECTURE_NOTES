[Slides](https://ele.exeter.ac.uk/pluginfile.php/5531356/mod_resource/content/1/ECM1413-Workshop%20Tutotial%20Slides.pdf)


##### Contents
 - [[#Core Characteristics of RISC]]
 - [[#Pipelined Execution]]
 - 


##### Core Characteristics of RISC
**RISC** *(Reduced Instruction Set Computer)* architectures, like RISC-V, are designed for *efficiency* and *high performance*.
Key Features include:
 - **Small Instruction Set**
	 - Contains *fewer* and *simpler instructions* compared to CISC (Complex Instruction Set Computer) architectures.
 - **Single Cycle Execution**
	 - Most instructions complete in one CPU clock cycle.
 - **Load/Store Architecture**
	 - Memory access is restricted to specific load and store instructions; *all other operations are performed directly on registers*.
 - **Uniform Instruction Format**
	 - *Instructions* have a *fixed length*, which makes the *decoding* process *faster* and *simpler* for the hardware.
 - **Large Register Set**
	 - A *high number of general-purpose registers* are available to *minimise* the need for *frequent and slow memory accesses*.
 - **High Instruction Throughput**
	 - Optimised for pipelining, allowing most instructions to complete in a single clock cycle (CPI = 1) under ideal conditions.


##### Pipelined Execution
**Pipelining** is a central concept in modern RISC architectures where *multiple instructions* are executed *simultaneously* by *overlapping* their stages.
- **Main Advantage**
	- It increases *throughput* (the total number of operations completed per unit time).
	- However, it does not reduce the *latency* (the time it takes for a single instructions to finish/complete).
- **Performance Limits**
	- The speedup is ideally equal to the number of pipeline stage.
	- I.e. there are 5 stages (IF, ID, EX, MEM, and WB, which I will explain below), meaning that up to 5 instructions can be executed at any one time.
	- However, it is limited by:
		- Slowest stage.
		- Time needed to fill/drain the pipeline.
		- Plus "stalls" caused by instruction dependencies.


##### The 5 Stages of the RISC-V Pipeline
The following stages are a standard execution pipeline.
 - **Instruction Fetch (IF)**
	 - The *Program Counter* (PC) *sends the address to memory* to retrieve the next instruction.
	 - Then the PC is incremented by the word count (32-bits).
 - **Instruction Decode (ID)**
	 - The instruction is decoded.
	 - The required data is read from the register file.
 - **Execute (EX)**
	 - The Arithmetic Logic Unit (ALU) performs the required operation (e.g. addition or logical comparison).
 - **Memory Access (MEM)**
	 - If the instruction is a LOAD or STORE operation, data is read from or written to main memory.
 - **Write Back (WB)**
	 - The final result (from the ALU or memory) is written back into the designated register.


##### RISC-V Instruction Set Architecture
The following are the fundamental building blocks of the RISC-V architecture:
 - **Registers**
	 - It features *32 general-purpose registers* (named `x0` to `x31`).
	 - Each register is 32 bits (4 bytes) wide.
	 - It also includes a 32 bit Program Counter.
 - **Base ISA (I)**
	 - This is the set of *fundamental instructions* that *must be present in every implementation* of RISC-V.
	 - It includes instructions such as:
		 - Integer addition and subtraction.
		 - Integer load/store operations - moving data between registers and memory.
		 - Control flow instructions - jumps and branches.
	 - These are the instructions that are fetched and decoded in the IF and ID stages.
 - **Extensions (M)**
	 - Optional extensions to the instruction set.
	 - E.g. the extension "M" containing instructions for using a hardware unit dedicated to integer multiplication and division.


##### Instruction Formats and Branching
RISC-V uses several instruction formats to handle the different types of operations efficiently.
 - **R-Format**: Used for arithmetic and logical register-to-register operations.
 - **I-Format**: Used for instructions with *immediate values* (constants) and load instructions.
 - **S-Format and SB-Format**: Used for store and branch instructions, respectively.
 - **U-Format and UJ-Format**: Typically used for long immediate and jumps.


##### Branch Instructions
Branch Instructions (like `beq`, `bne`, `bge`) are used to control the program flow by comparing two the values within two registers.
 - **Non-taken Branch**:
	 - The PC simply moves to the next instruction, i.e. PC = PC + 4 (bytes).
	 - I.e. a branch that doesn't result in a PC value change.
 - **Taken Branch**:
	 - The PC jumps to a new address calculated by adding a signed immediate value (multiplied by 4 (bytes)) to the current PC value.
	 - I.e. a branch that results in the PC having to point to a different address than planned.









