[Slides](https://ele.exeter.ac.uk/pluginfile.php/5533804/mod_resource/content/1/ECM1413_25_26_Lecture_02_File_Management.pdf)


##### Contents
 - [[#What is a File?]]
 - [[#File Management in Linux]]
	 - [[#Everything is a File Approach]]
	 - [[#How Data is Found The Inode]]
 - [[#Physical Storage Magnetic vs. SSD]]
 - [[#Keeping an SSD Alive Wear Levelling]]


##### What is a File?
 - A ***file*** is a *named* collection of *related information* that is stored on *secondary storage* (non-volatile memory, e.g. HDD, SSD).
 - A ***file attribute*** is *metadata* (descriptive tag) that provides information about the *file's properties* and *controls its behaviour*, governing how the OS and applications handle the file.
 - Each file has a set of attributes:
	 - the *name* of the file (given by the user or application)
	 - an *identifier (ID)* for the file (a name given by the OS)
	 - a *file extension* which tells an application how to interpret the bit string, e.g. `.pdf`, `.doc`, `.png`, `.jpg`
	 - the *location* of the file on the storage device (where it starts and ends)
	 - the *size* of the file
	 - the *protection mode* of the file, governing who has access, e.g. who can read or write or delete or execute
	 - the *times* that the file was created/access/modified
 - When you right click on a file in the file explorer and click properties, you are looking at the file's metadata.


#### File Management in Linux
 - Linux has two distinctive features of the file system:
	 - an *everything-is-a-file* approach
	 - a tree-like *inode* pointer structure


##### Everything is a File Approach
 - In Linux, *everything is represented by a file* in the file system, whether it is a text document, a folder (directory), or even hardware like a keyboard.
 - The Linux kernel provides a ***Virtual File System (VFS)*** layer, which represents hardware devices and system resources as entries in the file tree.
 - This approach simplifies software development.
 - There are six types of files:
	 - ***Regular Files***
		 - These are what we typically think of as 'files'.
		 - They contain data, such as a plain text document, executable program, an image, or compressed archive.
		 - The system doesn't care about the internal format, all it 'sees' is a stream of bytes.
		 - Example file formats: `.txt`, `.pdf`, `.exe`, `.png`, `.zip`.
	 - ***Directories***
		 - In Linux, a ***directory*** is a special type of file that contains a list of names and the *inode numbers* (pointers) of the files that the directory contains.
		 - When you "open" a folder, you are reading a file that tells the OS where to find the files that the directory contains.
	 - ***Links (Hard Links)***
		 - A *direct pointer* to the *file ID* (given by the OS and independent of the name given by the user).
		 - If you *move the original file*, then the *link still works*.
		 - It points to the same inode (the physical data on the disk) as the original file.
	 - ***Symbolic Links (Soft Links)***
		 - A ***symbolic link*** is a small file that contains the *text path* (e.g. "C:\\Users\\name\\doc.txt") to another file.
		 - They are *like desktop shortcuts*, they point to the file's name, given by the user or application.
		 - They are also known as "*soft links*" or "*symlinks*".
		 - If you delete or move the target file, the soft link becomes "*broken*" because its just a pointer to a path that no longer exists.
	 - ***Pipes***
		 - In the file system, there are ***Named Pipes*** (also called FIFOs).
		 - These act like "*first-in, first-out*" (FIFO) buffers.
		 - One process writes data into the pipe file, and another process reads it out.
		 - It allows two *unrelated processes to communicate*, this links to the *microkernel OS structure in lecture 1*.
	 - ***Special Files***
		 - These are found in the `/dev` directory and act as gateways to hardware devices.


##### How Data is Found: The Inode
 - Files are stored in "*blocks*" on a storage device, usually 4096 bytes each.
 - The system uses an ***inode (index node)*** to keep track of where these blocks are located.
 - You have two types of pointers:
	 - ***Direct Pointers***:
		 - Point directly to a data block.
	 - ***Indirect Pointers***:
		 - If a file is too big for direct pointers (i.e. is larger than 4096 bytes), the system uses "indirect" pointers - essentially a block that contains a list of more pointers.


##### Physical Storage: Magnetic vs. SSD
 - You have two main technologies that are used to storage data permanently:
 - ***Magnetic (Hard Disk Drives)***: ![[Pasted image 20260120160133.png]]
	 - These use mechanical parts to read and write data:
	 - ***Platters***:
		 - These are the actual disks.
		 - They are made of a hard material and coated with a magnetic substance.
		 - A single HDD usually has several platters stacked on top of each other.
		 - The polarity of the magnetic substance is used to store a 1 or 0.
	 - ***Heads***:
		 - These are small sensors that hover extremely close to the platters.
		 - The head is used to read data by sensing the magnetic polarity and writes data by changing the magnetic polarity.
		 - When a head collides with a platter, it is known as a ***Head Crash***.
		 - When a head crash occurs, the data in the effected region is permanently corrupted.
	 - ***Movable Arms***:
		 - This holds the head and moves the head from the centre to edge of the platter so it can reach different parts of the platter.
	 - These are logical abstractions for areas in storage:
	 - ***Tracks***:
		 - These are like the lanes on a running track.
		 - They are concentric circles around the centre of the platter.
	 - ***Sectors***:
		 - Each track is chopped up into small segments called *sectors*.
		 - A sector is the *smallest unit of data* that can be moved to or from the drive (usually 512 or 4096 bytes).
	 - ***Cylinder***:
		 - Since there are multiple platters stacked up, a cylinder refers to the same track number across all platters.
		 - If the arm is positioned to read from track 5 on the top platter, it is also positioned to read track 5 on all the platters below it simultaneously.
	 - When reading a file:
	 - ***Seek***:
		 - The movable arm physically slides the head in or out to the correct cylinder (right track).
	 - ***Rotation***:
		 - The platters spin at thousands of miles per hour until the specific sector containing your data passes under the head.
	 - ***Transfer***:
		 - The head sense the magnetic bits on the platter and sends that signal to the computer as data.
 - ***Solid State Drives (SSD)***:
	 - SSDs have no moving parts and use ***flash memory***, which stores data as *electrical charges inside transistors*.
	 - While a magnetic drive is divided into sectors, an SSD is organised into *pages* and *blocks*.
	 - ***Page***:
		 - The *smallest unit* for reading and writing data.
		 - Similar to a sector in a magnetic drive.
		 - Has a typical size of 4KB or 4096 bytes.
	 - ***Block***:
		 - A larger unit made up of *many pages*.
		 - E.g. a 512KB block may contain 128 pages.
	 - ***The Golden Rule***:
		 - You can write to a single page.
		 - However, you can only erase an entire block at once.
	 - ***The Overwriting Problem***:
		 - You can read and write fast if the page is empty.
		 - To erase an existing block, high voltage is required and it must be used on the entire block.
		 - Therefore, if you want to change a file in a block, the SSD has to erase the whole block first.
		 - This makes overwriting slower than writing to an empty block.
	 - ***The Trade-off***:
		 - SSDs are much faster, more reliable than magnetic storage and are more power efficient, but they wear out every time you write data to them.


##### Keeping an SSD Alive: Wear Levelling
 - Since SSD blocks can only be written to a *finite number of times before they fail*, the system uses ***Wear-Levelling*** to *spread the writes/"wear" evenly across the entire drive*.
 - ***Dynamic Wear-Levelling***:
	 - When new data is being saved, the system looks for the block that has been used the *least* (the least-recently-used or LRU block) and writes here.
	 - The problem: if you have cold data (like a photo you haven't touched in years), it just sits in its block. Therefore, that block never gets used for new writes, while other blocks keep getting worn down.
 - ***Static Wear-Levelling***:
	 - This is more thorough.
	 - It does everything that dynamic wear levelling does, but it also periodically *moves* that *"cold data"* to a worn block so it can use the *fresh, unused block for new data*.





