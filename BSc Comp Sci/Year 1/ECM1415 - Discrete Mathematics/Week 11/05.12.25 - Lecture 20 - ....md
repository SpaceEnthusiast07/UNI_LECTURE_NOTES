[Slides](https://ele.exeter.ac.uk/pluginfile.php/5422561/mod_resource/content/1/Graph%20Handouts.pdf)


##### Contents
 - [[#Paths]]
	 - [[#Path Counting]]


#### Paths
##### What is a Path?
 - A ***path*** on a graph from vertex $u$ to vertex $v$ is *a sequence of edges*; $e_{1}, e_{2}, \dots, e_{n}$
$$(u, x_1),(x_1, x_2),(x_2, x_3), \dots,(x_i , x_{i+1}),(x_{i+1}, x_{i+2}), \dots,(x_n, v)$$
 - For vertices $x_{i}$
 - Example - the bold line represents the path between vertices $1$ and $8$: ![[Pasted image 20251205094527.png]]
 - A path which *starts an ends on the same point* is a ***circuit***
 - A path *visits* the vertices $x_{1}, x_{2}, \dots$ and *traverses* the edges $e_{1}, e_{2}, \dots$
 - A path is ***simple*** if it has *no repeated edges*


##### Connected Graphs
 - A ***connected*** graph has a *path between every pair of vertices*
 - If it is not connected, we say the graph is *disconnected* into a number of *components*
 - Example: ![[Pasted image 20251205095835.png]]
	 - No!


##### Path Counting
 - If the vertices of $G$ are labelled $1,2,3,4,\dots$, then the number of paths of length $r$ from vertex $i$ to $j$ is equal to:
$$(A^r)_{ij}$$
 - Where $A$ is the adjacency matrix of $G$ ![[Pasted image 20251205102941.png]]
 - Proof: ![[Pasted image 20251205103001.png]]


##### Eulerian Path/Circuit
 - An ***Eulerian Path*** is a simple path (no backtracking) containing *every edge* in the graph $G$
 - A ***Eulerian circuit*** is a *closed Eulerian path*
 - Example: ![[Pasted image 20251205103338.png]]![[Pasted image 20251205103353.png]]![[Pasted image 20251205103424.png]]
 - Proof: ![[Pasted image 20251205103453.png]]![[Pasted image 20251205103518.png]]


##### Hamiltonian Path/Circuit
 - A ***Hamiltonian path*** is a simple path (no backtracking) visiting *every vertex* in the graph $G$
 - A ***Hamiltonian circuit*** is a *closed Hamiltonian path*
 - There is a simple algorithm for finding Eulerian paths, but no simple algorithm for finding Hamiltonian paths.


##### Weighted Graphs
 - A ***weighted graph*** is a graph with some number $w_{ij} > 0$ associated with every edge $(v_{i},v_{j})$
 - $w_{ij}$ is an element of the *weight matrix* $w$ ![[Pasted image 20251205103703.png]]
 - Example: ![[Pasted image 20251205103727.png]]


##### Dijkstra's Shortest Path Algorithm
 - Algorithm: ![[Pasted image 20251205103826.png]]![[Pasted image 20251205103926.png]]


#### Trees
##### What are Trees?
 - A ***tree*** is a simple graph with no circuits (two ways to the same node) ![[Pasted image 20251205104056.png]]


##### Tree Edges
 - A tree on $n$ vertices has $n-1$ edges
 - Proof: ![[Pasted image 20251205104139.png]]


##### Tree Structure#
 - Trees are drawn inverted compared to regular, natural trees
 - The top most node is called the ***root node*** and has no parents
 - A node that is beneath another node is called its ***child node***
 - A node with a child node is called a ***parent node***
 - Nodes without any children are called ***leaf nodes***


##### Binary Trees
 - You can have many types of trees
 - The graph of all other vertices relative to that vertex in a directed tree often called a rooted tree
 - One most common type is the binary tree
 - Each node has at most 2 children
 - Example: ![[Pasted image 20251205104516.png]]


##### Binary Tree Height
 - The ***height*** of any binary tree is the *length* of the *longest path* from the root to any other node
 - Proof: ![[Pasted image 20251205105108.png]]


##### Binary Search Tree
 - A ***binary search tree*** is a version of a binary tree where *values are associated with each node*
 - Restrictions: the right child's value should always be greater than its parent and the left child less than its parent
 - Example - store the array $\{6,9,4,1,5\}$ in a binary search tree: ![[Pasted image 20251205105919.png]]


#### Colouring
 - Dual Graph: ![[Pasted image 20251205110054.png]]![[Pasted image 20251205110102.png]]