[Slides](https://ele.exeter.ac.uk/pluginfile.php/5420511/mod_resource/content/1/Week%2011b%20-%20Dynamic%20Programming.pdf)


##### Contents
 - [[#What is Dynamic Programming?]]
 - [[#Why does DP Exist?]]
 - [[#Two Ways to Implement DP]]
 - [[#Recognising DP Problems]]
 - [[#How to Actually Solve DP Problems]]
 - [[#Example - Coin Change]]


##### What is Dynamic Programming?
 - Dynamic Programming is a strategy for solving complex problems by *breaking them into smaller subproblems*, solving each subproblem *once*, and *reusing those solutions* to avoid unnecessary work.
 - It is used when a problem has two key properties:
	 1. ***Optimal Substructure*** - The best solution to the whole problem can be built from the best solutions to the smaller parts
	 2. ***Overlapping Subproblems*** - The same subproblems appear again and again (e.g. Fibonacci)


##### Why does DP Exist?
 - Some problems naturally break into smaller problems
 - E.g. computing Fibonacci numbers: `fib(n) = fib(n-1) + fib(n-2)`
 - A naive recursive solution recomputes the same values repeatedly
 - DP fixes this waste by:
	 - Storing solutions - so you don't recalculate
	 - Building solutions systematically
 - This leads to enormous speed improvements


##### Two Ways to Implement DP
 1. Memoisation (Top-Down)
	 - You write a recursive solution
	 - Add a dictionary/array that stores results
	 - If a subproblem was solved before $\to$ just return the cached answer
	 - Works "on demand": only solves subproblems you need
	 - Pros: Easy conceptually, mirrors recursion
	 - Cons: Recursion overhead can be high
 2. Tabulation (Bottom-Up)
	 - You fill a table iteratively
	 - Start with the simplest subproblems (base case)
	 - Work your way up to the final answer
	 - Pros: Faster, avoids recursion
	 - Cons: Sometimes harder to think of


##### Recognising DP Problems
 - A problem is suitable for DP if:
 - Optimal Substructure - Example: In coin change, the bast way to make £11 includes that best way to make £10
 - Overlapping Subproblems - Example: Coin change repeatedly needs solutions to amounts, recursion recomputes these over and over $\to$ extremely slow


##### How to Actually Solve DP Problems
 - Step 1 - Define the subproblem
	 - What is the smallest unit of the problem?
	 - Examples:
		 - `dp[i] = minimum coins to make amount i` 
		 - `dp[i][j] = maximum value with first i items and capacity j`
 - Step 2 - Find the recurrence
	 - How are the subproblems connected?
	 - Example: `dp[i] = 1 + min(dp[i-coin] for each coin`
 - Step 3 - Choose memoisation or tabulation
	 - Recursion + dictionary = memoisation
	 - Iterative array = tabulation
 - Step 4 - Compute and return the result


##### Example - Coin Change
The problem
	 - Given coin denominations (e.g. 1,2,5)
	 - and a target amount (e.g. 11)
	 - find the fewest coins required
*Recursive Solution (Slow)*
 - Try every coin: `minCoins(amount) = 1 + min(minCoins(amount - coin))`
 - Problems:
	 - Repeats the same calls many times
	 - Exponential time
*Memoisation (Top-Down)*
 - Add a dictionary: 
```python
memo = {}
if amount in memo: return memo[amount]
```
 - Benefits:
	 - Each amount solved once
	 - Much faster
*Tabulation (Bottom-Up)*
 - Build an array:
```python
dp = [0] + [infinity]*(amount)
for i in rnage(1, amount+1):
	for coin in coins:
		if i - coin >= 0:
			dp[i] = min(dp[i], dp[i-coin] + 1)
```
 - Result is in `dp[amount]`
 - This is the most efficient version






