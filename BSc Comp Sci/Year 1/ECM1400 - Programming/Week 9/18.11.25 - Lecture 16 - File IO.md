[Slides](https://ele.exeter.ac.uk/pluginfile.php/5412857/mod_resource/content/1/Week%209b%20-%20File%20IO.pdf)


##### Contents
 - [[#What is File I/O]]
 - [[#Why it Matters]]
 - [[#File Types]]
 - [[#Opening and Closing Files in Python]]
 - [[#Reading Data from Files in Python]]
 - [[#Writing to Files in Python]]
 - [[#File Modes in Python]]
 - [[#Working with File Paths in Python]]
 - [[#Navigating the File System]]
 - [[#Best Practices for File I/O]]
 - [[#Using NumPy for File I/O]]
 - [[#NumPy and Memory Efficiency]]


##### What is File I/O
 - File I/O is the act of reading or writing data to files


##### Why it Matters
 - Normally, when a program ends, all data is lost
 - File I/O allows the program to store data permanently, so you can:
	 - Save user settings
	 - Load data later
	 - Share information between programs
	 - Analyse large datasets
- It is an essential feature in all software


##### File Types
 - ***Plain Text*** - `.txt`
	 - Contains simple characters
	 - Great for logs, notes, or small datasets
 - ***Comma-Separated Values*** - `.csv`
	 - Tables stored as text
	 - Used a lot in data science
 - ***JavaScript Object Notation*** - `.json`
	 - Structured data like dictionaries/lists
	 - Popular for APIs and configuration files
 - ***Binary Files*** - commonly `.bin`
	 - Store raw bytes without header information/metadata
 - Specialised Formats
	 - Excel (`.xlsx`) - Microsoft Excel spreadsheets
	 - HDF5 - efficient for very large datasets
 - Each file type requires different read/write functions


##### Opening and Closing Files in Python
 - The `open()` function is used to access files
```python
file = open("data.csv", "r")
```
 - Two main arguments:
	 - Filename - the file or path to file
	 - Mode - 
		 - `"r"` $\rightarrow$ read
		 - `"w"` $\rightarrow$ write (overwrites any existing data)
		 - `"a"` $\rightarrow$ append (add onto the end)
		 - `"x"` $\rightarrow$ create a new file, otherwise error if file already exists
 - Ensure the file is closed using `file.close()` once finished with. This prevents memory leaks and corruption
 - Best Practice: use `with`
	 - `with` automatically closes a file at the end or if something goes wrong
```python
with open("data.csv", "r") as file:
	text = file.read()
```


##### Reading Data from Files in Python
 - `read()`
	 - Reads the entire file as one string
	 - Good for small files
 - `readline()`
	 - Reads one line at a time
 - `readlines()`
	 - Returns all lines as a list of strings


##### Writing to Files in Python
 - `write()`
	 - Write a single string to a file
 - `writelines()`
	 - Writes a list of strings to the file
 - Using `print()`
	 - `print("Hello!", file=file)`
	 - Automatically adds a newline to the line


##### File Modes in Python
![[Pasted image 20251118113810.png]]


##### Working with File Paths in Python
 - Absolute Paths
	 - Full path from root of computer
	 - E.g. `/home/cam/uni/project/data.txt`
 - Relative Paths
	 - Relative to where the program is running from
	 - E.g. `data.csv` or `../folder/data.csv`
	 - `..` = parent directory
 - Helpful Modules
	 - `os.path` - Functions for joining paths, checking existence, etc.
	 - `pathlib` - Object-oriented and easier to use
	 - Example:
```python
from pathlib import Path

p = Path("data.csv")
print(p.exists())
```


##### Navigating the File System
 - Listing directory contents:
```python
os.listdir()
os.scandir()
```
 - Checking if files exist:
```python
os.path.exists("file.txt")
Path("file.txt").exists()
```
 - Getting file metadata:
```python
os.stat("file.txt")
```


##### Best Practices for File I/O
 - Use context managers - `with`
	 - automatically closes files
 - Handle error
	 - use `try-catch` blocks to ensure the program doesn't crash
 - Specify encoding
	 - Especially when working with text containing special characters
	 - `open("file.txt", encoding="uft-8")`
 - Handle large files efficiently
	 - Process them line-by-line
	 - Read chucks
	 - Use generators
	 - This avoids loading entire huge files into memory


##### Using NumPy for File I/O
 - NumPy offers fast data loading/saving functions
 - *Reading Data*
	 - `numpy.load()`
		 - loads NumPy binary files, `.npy` and `.npz`
	 - `numpy.loadtxt()` or `numpy.genfromtxt()`
		 - Good for CSV-type text files
		 - Supports delimiters
		 - Handles missing values
		 - Allows type conversion
 - *Writing Data*
	 - `numpy.savetxt()`
		 - Save arrays to `.txt` or `.csv`
	 - `numpy.save()`
		 - Save a single array as a binary file (`.npy`)
		 - Fast and efficient
	 - `numpy.savez()`
		 - Save multiple arrays in one compressed file (`.npz`)


##### NumPy and Memory Efficiency
 - Large datasets can be huge in memory, so:
 - Memory-efficient arrays
	 - NumPy stores data in contiguous blocks $\rightarrow$ more efficient than Python lists
 - Lazy loading
	 - Load data only when needed
	 - Load sections of data that are needed
 - Compression
	 - NumPy `.npz` files can be stored in compressed form to save disk space












