[Slides](https://ele.exeter.ac.uk/pluginfile.php/5420507/mod_resource/content/1/Week%2010b%20-%20Sorting.pdf)


##### Contents
 - [[#What is sorting?]]
 - [[#Time Complexity of Sorting]]


##### What is sorting?
 - Sorting means putting data into a particular order, usually:
	 - Numeric order - e.g. 1,2,3,4,5,6,...
	 - Lexicographical order (alphabetical)
 - We sort data because it makes many other takes much faster: searching, analysing, displaying data, etc.
 - Sorting is used in databases, search engines, file systems and everywhere else


##### Time Complexity of Sorting
 - Different algorithms take different amounts of time to run
 - Key Idea:
	 - Any sorting algorithms that works by comparing items can do no better than $O(n \log n)$ on average
 - Terminology:
	 - *Time complexity* $\to$ How the algorithm's running time grows as the amount of data grows
	 - Space Complexity $\to$ How much extra memory the algorithm uses
	 - $n \to$ Number of items
	 - $O(n^2) \to$ Slow for large data
	 - $O(n \log n) \to$ Fast and scalable


##### Categories of Sorting Algorithms
 - Simple, iterative sorts - $O(n^2)$
	 - Bubble sort
	 - Selection sort
	 - Insertion sort
 - Efficient, divide-and-conquer sorts - $O(n \log n)$
	 - Merge sort
	 - Quick sort
	 - Heap sort


##### Bubble Sort
 - Repeatedly walk through the list and _bubble_ the largest values to the end by swapping adjacent out-of-order elements.
 - Steps:
	 1. Start at the beginning of the list
	 2. Check each pair of adjacent elements
	 3. Swap if they are in the wrong order
	 4. Repeat until no swaps are performed
 - Complexity:
	 - Worst/average case $\to$ $O(n^2)$
	 - Best case (already sorted) $\to$ $O(n)$ - only one pass needed
 - Mostly used for teaching, rarely used in real systems
 - Python Example:
```python
def bubbleSort(array):
	swapped = True
	
	while swapped:
		for i in range(len(array)):
			if (array[i] > array[i+1] and i+1 < len(array)):
				temp = array[i+1]
				array[i+1] = array[i]
				array[i] = temp
	
	return array
```


##### Selection Sort
 - Main Idea:
	 - Repeatedly find the smallest element in the unsorted portion and move it to the start
 - Steps:
	 1. Look through the list to find the minimum
	 2. Swap it with the first unsorted position
	 3. Repeat for the remainder of the list
 - Complexity:
	 - Always $O(n^2)$ - even if the list is already sorted
 - Good for:
	 - Finding the top X smallest/largest items without sorting everything
 - Python example:
```python
def selectionSort(array):
	unsortedSection = 0
	start = time.time()
	
	while unsortedSection < len(array):
		smallestValue = 1e100
		smallestValueIndex = 0
		
		for i in range(unsortedSection, len(array)):
			if (array[i] < smallestValue):
				smallestValue = array[i]
				smallestValueIndex = i
		
		array[smallestValueIndex] = array[unsortedSection]
		array[unsortedSection] = smallestValue
		unsortedSection += 1
	
	end = time.time()
	return end - start
```


##### Insertion Sort
 - Main Idea:
	 - Build up the sorted portion of the list by inserting each new element into its proper place
 - Steps:
	 1. Start at the second element
	 2. Compare it to the items before it
	 3. Shift larger elements right
	 4. Insert the element into the correct place
 - Complexity:
	 - Best case (already sorted) $\to O(n)$
	 - Worst case (reverse order) $\to O(n^2)$
	 - Average $\to O(n^2)$
 - Good for:
	 - Small datasets
	 - Nearly-sorted lists
 - Python example:
```python
def insertionSort(array):
	start = time.time()
	
	for i in range(1, len(array)):
		key = array[i]
		j = i-1
		
		while(j >= 0 and key < array[j]):
			array[j+1] = array[j]
			j -= 1
		
		array[j+1] = key
	
	end = time.time()
	results["insertion"] = end - start
```


##### Merge Sort
 - Main Idea:
	 - Divide the list in half repeatedly until every piece has 1 element, then merge pieces back together in sorted order
 - Steps:
	 1. Divide - Split list into halves recursively
	 2. Conquer - Sort each half (recursive calls)
	 3. Combine - Merge sorted halves into a full sorted list
 - Complexity:
	 - Always $O(n \log n)$
	 - Uses extra memory due to the merging process
 - Notes:
	 - Very stable and predictable
	 - Great for very large datasets
 - Python example:
```python

```

