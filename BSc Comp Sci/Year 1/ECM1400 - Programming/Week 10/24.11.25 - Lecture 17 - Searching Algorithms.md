[Slides](https://ele.exeter.ac.uk/pluginfile.php/5420506/mod_resource/content/1/Week%2010a%20-%20Searching.pdf)


##### Contents
 - [[#Why Algorithm Complexity Matters]]
 - [[#Big O Notation The Core Idea]]
 - [[#Common Complexity Classes]]


##### Why Algorithm Complexity Matters
 - When we write programs, different algorithms can solve the same problem - but some do it much faster or use less memory than others
 - To compare algorithms, we use *Big O notation*, which describes how quickly the runtime grows as the input size increases
 - For example:
	 - Searching 10 items vs 1,000,000 items
	 - Sorting a list of 50 items vs 50,000 items
 - Even if two algorithms work, one can be dramatically slower as data grows


##### Big O Notation: The Core Idea
 - Big O describes
	 - *Growth rate* - How fast runtime increases as the input grows
	 - *Worst-case performance* - Big O tells you the maximum amount of work you may need
	 - Dominant term - We ignore small details like constants and lesser terms
		 - Example: $T(n) = 3n^2 + 5n + 3 \rightarrow O(n^2)$
		 - As $n$ grows, $n^2$ grows the fastest, i.e. the most dominant term


##### Common Complexity Classes
 - $O(1)$ - ***Constant Time***
	 - Takes the same amount of time regardless of input size
	 - Examples:
		 - Accessing array element - `array[3]`
		 - A simple arithmetic operation
 - $O(n)$ - ***Linear Time***
	 - Work grows directly with input size
	 - Examples:
		 - Scanning every item in a list (linear search)
		 - Printing each element in an array
 - $O(\log_{2} n)$ - ***Logarithmic***
	 - Each step cuts the problem in half
	 - Examples:
		 - Binary search
		 - Operations in balanced binary search trees
	 - Grows very slowly, faster than linear algorithms
 - $O(n^2)$ - ***Quadratic***
	 - Nested loops over the same data
	 - Examples:
		 - Bubble sort
		 - Checking all pairs in a list
	 - If $n$ doubles, work quadruples
 - Space/Time Trade off
	 - Sometimes you can:
		 - Use more memory to make the algorithm faster
		 - Or, use less memory but accept that the algorithm is slower
	 - Example:
		 - Using a *hash table* uses more memory, but speeds up lookups




