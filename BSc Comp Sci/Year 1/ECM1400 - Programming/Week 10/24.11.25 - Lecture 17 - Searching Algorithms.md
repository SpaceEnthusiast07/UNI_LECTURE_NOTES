[Slides](https://ele.exeter.ac.uk/pluginfile.php/5420506/mod_resource/content/1/Week%2010a%20-%20Searching.pdf)


##### Contents
 - [[#Why Algorithm Complexity Matters]]
 - [[#Big O Notation The Core Idea]]
 - [[#Common Complexity Classes]]
 - [[#Intro to Searching]]
	 - [[#Linear Search]]
	 - [[#Binary Search - Divide & Conquer]]
	 - [[#Graph Searches]]
	 - [[#More Advanced Pathfinding Algorithms]]
	 - [[#Travelling Salesman Problem (TSP)]]


##### Why Algorithm Complexity Matters
 - When we write programs, different algorithms can solve the same problem - but some do it much faster or use less memory than others
 - To compare algorithms, we use *Big O notation*, which describes how quickly the runtime grows as the input size increases
 - For example:
	 - Searching 10 items vs 1,000,000 items
	 - Sorting a list of 50 items vs 50,000 items
 - Even if two algorithms work, one can be dramatically slower as data grows


##### Big O Notation: The Core Idea
 - Big O describes
	 - *Growth rate* - How fast runtime increases as the input grows
	 - *Worst-case performance* - Big O tells you the maximum amount of work you may need
	 - Dominant term - We ignore small details like constants and lesser terms
		 - Example: $T(n) = 3n^2 + 5n + 3 \rightarrow O(n^2)$
		 - As $n$ grows, $n^2$ grows the fastest, i.e. the most dominant term


##### Common Complexity Classes
 - $O(1)$ - ***Constant Time***
	 - Takes the same amount of time regardless of input size
	 - Examples:
		 - Accessing array element - `array[3]`
		 - A simple arithmetic operation
 - $O(n)$ - ***Linear Time***
	 - Work grows directly with input size
	 - Examples:
		 - Scanning every item in a list (linear search)
		 - Printing each element in an array
 - $O(\log_{2} n)$ - ***Logarithmic***
	 - Each step cuts the problem in half
	 - Examples:
		 - Binary search
		 - Operations in balanced binary search trees
	 - Grows very slowly, faster than linear algorithms
 - $O(n^2)$ - ***Quadratic***
	 - Nested loops over the same data
	 - Examples:
		 - Bubble sort
		 - Insertion sort
		 - Checking all pairs in a list
	 - If $n$ doubles, work quadruples
 - $O(2^n)$ - ***Exponential***
	 - The run time doubles with each additional element in the input
	 - Examples:
		 - Generating the power set of a set
		 - Finding the shortest path in a graph using brute force
 - Space/Time Trade off
	 - Sometimes you can:
		 - Use more memory to make the algorithm faster
		 - Or, use less memory but accept that the algorithm is slower
	 - Example:
		 - Using a *hash table* uses more memory, but speeds up lookups


#### Intro to Searching
 - A ***searching algorithm*** finds a particular item inside some dataset
 - Some searching algorithms include:
	 - Linear search
	 - Binary search
	 - BFS (Breadth-First Search)
	 - DFS (Depth-First Search)
 - Each algorithm has a different efficiency depending on:
	 - Data structure (list, tree, graph)
	 - Whether the data is sorted
	 - The shape and size of the search space


##### Linear Search
 - How it works:
	 1. Start at the first element
	 2. Compare with target
	 3. If found, return index or Boolean value true
	 4. Else, move to next element
	 5. Repeat until found or list ends
 - Complexity:
	 - Worst case: $O(n)$ - target is last or missing
	 - Best case: $O(1)$ - target is first
	 - Average case: $O(n)$
 - Used for:
	 - Unsorted lists where you have no structure to exploit
 - Python example:
```python
def linearSearch(target, array):
	for i in range(len(array)):
		if (array[i] == target):
			return i
	return -1

print(linearSearch(5, [45,2,76,1,5,67,8]))

--OUTPUT-------------------------------------------------------------
4
```


##### Binary Search - Divide & Conquer
 - Requirement: Array must be *sorted*
 - How it works:
	 1. Check the middle element
	 2. If target is $<$ middle $\to$ search left half
	 3. If target is $>$ middle $\to$ search right half
	 4. Repeat until target is found or not present
 - Complexity:
	 - $O(\log_{2}n)$ - extremely efficient
 - Binary search is fast because each step halves the remaining work
 - Python example:
```python
def binarySearch(target, array, start, end):
	# Ensure the array is sorted
	array = sort(array)
	
	# Find the middle value
	middle = (start + end) / 2
	
	#Check if the middle value is the target
	if (target == array[middle]):
		return middle
	elif (target > array[middle]):
		return binarySearch(target, array, middle + 1, end)
	elif (taregt < array[middle]):
		return binarySearch(target, array, start, middle - 1)

array = [45,2,76,1,5,67,8]
print(binarySearch(5, array, 0, len(array)))

--OUTPUT-------------------------------------------------------------
2
```


##### Graph Searches
 - Graphs and trees represent connected structures, e.g.:
	 - social networks
	 - maps
	 - file systems
	 - website links
***Breadth-First Search (BFS)***
 - Explores a graph or tree level by level
 - Idea:
	 1. Visit node
	 2. Visit all neighbouring nodes (on same level)
	 3. Move to next layer/level and repeat
 - Uses:
	 - Finding the shortest path in an unweighted graph
	 - Checking connectivity
	 - Solving puzzles like finding shortest moves in a maze
 - Data structure: Queue
***Depth-First Search (DFS)***
 - Goes as deep as possible before back tracking
 - Idea:
	 1. Visit node
	 2. Visit unvisited child
	 3. Continue until node is a leaf (i.e. a dead end)
	 4. Backtrack to parent node and repeat
 - Uses:
	 - Detecting cycles
	 - Solving maze-like puzzles
	 - Topological sorting
	 - Exploring all possibilities
 - Data structure: Stack or recursion


##### More Advanced Pathfinding Algorithms
 - ***Dijkstra's Algorithm***
	 - Finds the shortest path with weights (e.g. travel time)
	 - Uses a priority queue to always expand the cheapest path so far
	 - Slower than BFS but handles weighted edges
	 - Used in GPS navigation
 - ***A\****
	 - Builds on Dijkstra's but adds a heuristic (estimate of distance to goal)
	 - Much faster than Dijkstra's for many problems
	 - Guaranteed optimal if the heuristic is good
	 - Used in AI, robotics and games
 - ***Greedy Best-First Search***
	 - Only uses the heuristic - ignores actual path cost
	 - Fast but does not guarantee the shortest path
	 - Useful when speed matter more than accuracy
 - ***Bidirectional Search***
	 - Searches from start and from goal simultaneously
	 - When the two meet, path is found
	 - Can shrink search time dramatically
 - ***Bellman-Ford Algorithm***
	 - Slower than Dijkstra's
	 - But works even when there are negative edge weights (which Dijkstra's cannot handle)
	 - Used in network routing where costs can fluctuate


##### Travelling Salesman Problem (TSP)
 - Problem: “Find the shortest route that visits all cities once and returns to the start.”
 - Key Points:
	 - The number of possible routes = factorial of number of cities
	 - Complexity grows exponentially
	 - No known polynomial-time exact solution
	 - Real systems use heuristics or approximation algorithms
 - TSP shows why exponential algorithms become impractical very quickly







