[Slides](https://ele.exeter.ac.uk/pluginfile.php/5583028/mod_resource/content/4/L09-Object_class_sealed_classes_and_casting_note_taking_form.pdf)


##### Contents
 - [[#Constructors]]
 - [[#The Super Keyword]]
 - [[#Why no Super.Super?]]
 - [[#The Object Class]]
 - [[#Inheritance Summary]]
 - [[#The Final Keyword]]
 - [[#Casting]]
 - [[#The InstanceOf Operator]]
 - [[#Multiple Top-Level Classes in a Single File]]
 - [[#Sealed Classes]]


##### Constructors
 - Constructors **are not inherited**!
 - Each class *defines its own constructor*.
 - However, a *class can invoke its superclass' constructor* using the `super()` keyword.

>[! Warning] You can only access the parent class' constructor if the access modifier allows it.

 - If the subclass has no `super` keyword present, the compiler will automatically insert a `super` call to the parent's *no-argument constructor*.
 - Therefore, if the *parent does not define a no-argument constructor*, you will receive a *compiler error*.

>[! Tip] If no constructor is defined in a class, the compiler will automatically insert the default no-argument constructor.

Example usage of the `super` keyword:
```java
// Define the super class
public class Animal {
	// Private attributes
	private int age;
	private String colour;
	
	// Constructor
	public Animal(int age, String colour) {
		this.age = age;
		this.colour = colour;
	}
	
	// Getter/Setter methods
	// ...
}

// Define child/sub class Dog
public class Dog extends Animal {
	// Private attributes
	private int collarSize;
	
	// Constructor
	public Dog(int age, String colour, int collarSize) {
		// This must be the first statement in the constructor
		super(age, colour);
		this.collarSize = collarSize;
	}
	
	// Getter/Setter methods
	// ...
}
```


##### The Super Keyword
The `super` keyword refers to the super/parent class.
 - To call the superclass' *constructor*: `super(arg1, arg2, ...);`
 - Call a superclass' *method*: 
	 - E.g. `super.sleep();` for a example class Animal.
	 - This respects the access modifier of the respective method.
 - You can access a superclass' hidden/private attributes:
	 - E.g. `int age = super.age;`
The `super` keyword can only be used within a sub/child class.

Example usage (uses above example):
```java
// Define the super class
public class Animal {
	// Private attributes
	private int age;
	private String colour;
	
	// Constructor
	public Animal(int age, String colour) {
		this.age = age;
		this.colour = colour;
	}
	
	// Getter/Setter methods
	// ...
}

// Define child/sub class Dog
public class Dog extends Animal {
	// Private attributes
	private int collarSize;
	
	// Constructor
	public Dog(int age, String colour, int collarSize) {
		// This must be the first statement in the constructor:
		super(age, colour);
		this.collarSize = collarSize;
		// Call the superclass' private age attribute
		int superAge = super.age;
	}
	
	// Getter/Setter methods
	// ...
}
```


##### Why no Super.Super?
 - Accessing grandparent members (or higher up the inheritance tree) geos against the encapsulation principles.
 - Therefore, you cannot access `super.super`.
 - *Encapsulation* in Java is *concerned with the current class* and members of the *immediate parent class*.

>[! Tip] Non-overridden methods further up the inheritance tree can still be accessed.


##### The Object Class
 - This class contains many helpful utility functions, defined below.

>[! Tip] All Java classes inherit from this class and each class can override them.

 - `toString()`
	 - Returns a human readable string representation of the object.
	 - By default it returns the memory address of the object.
 - `equals(Object obj)`
	 - Indicates if two objects are identical.
	 - By default it compares memory address references.
 - `getClass()`
	 - Returns the name of the runtime class of this object.
 - `clone()`
	 - Performs a deep copy of the object. Produces an identical but independent copy of the specified object.
	 - With this function, the copy is stored in a separate memory location, but contains the same values.
	 - On arrays, this is a shallow copy.


##### Inheritance Summary
![[Pasted image 20260210110949.png]]


##### The Final Keyword
>[! Tip] This keyword has different but understandable meanings depending on how you use it.

 - A `final` *attribute* is a constant:
	 - E.g. `final int MAX_BORROW_BOOKS = 5;`.
 - A `final` *method* cannot be overridden:
	 - E.g. `final void eat() {...}`.
 - A final class cannot be extended, i.e. no inheritance:
	 - E.g. `public final class String {...}`.
	 - The `String` class cannot have any subclasses.

>[! Warning] This keyword is distinct from the finally keyword, which we will cover later, but is to do with Exception handling.


##### Casting
>[! Warning] Casting can only be achieved when using inheritance, i.e. between a parent and child class.

 - **Upcasting**:
	 - The process of assigning an instance of a subclass to a reference of a superclass.
	 - Complicated sounding definition, but with an example, it makes sense.
	 - E.g. `Animal dog = new Dog("black", 5, 10);`.
	 - I.e. you *declare a variable as being the superclass*, but instantiate it with an *instance of the subclass*.
	 - I.e. (2) Assigning a *subclass instance to a superclass reference*.
	 - You are able to invoke the superclass' methods.
	 - If a method is overridden, the subclass' version is invoked.
	 - This is always a safe process however, you are limited to methods defined in the superclass.

>[! Warning] You CANNOT invoke methods that only exist in the Dog class, e.g. `dog.bark();` <-- Compilation error!

 - **Downcasting**:
	 - Definition: Revert a substituted instance back to a subclass reference.
	 - I.e. reverting a reference back to a subclass type.
	 - Example: 
		 - `Animal dog = new Dog(arguments...);`
		 - `Dog dog2 = (Dog) dog; // Needs type casting operator`
	 - Downcasting is not always safe:
		 - `Animal cat = new Cat(arguments...);`
		 - `Dog dog2 = (Dog) cat; // Throws a ClassCastException at Runtime`
>[! Tip] To avoid this exception, it is common to check the object's class before downcasting, using the `instanceof` operator.


##### The InstanceOf Operator
 - The `instanceof` operator is used to *check if an object* is an *instance of a particular class* before downcasting.
 - Example usage:
```java
// Ensure dog is an instance of the Dog class
Animal dog = new Dog("Fiddo", 4, 24)

if (dog instanceof Dog) {
	// Downcast safely!
	Dog dog2 = (Dog) dog;
	// Now do something with dog2
}
```
 - More examples of how `instanceof` works:
```java
Dog dog1 = new Dog("black", 5, 10);
System.out.println(dog1 instanceof Dog); // true
System.out.println(dog1 instanceof Animal); // true
```
 - Further examples:
```java
Animal d2 = new Dog("red",2,10); //upcasting
System.out.println(d2 instanceof Dog); // true
System.out.println(d2 instanceof Animal); // true
System.out.println(d2 instanceof Object); // true
System.out.println(d2 instanceof Cat); // false
```
 - Example from slides: ![[Pasted image 20260211185818.png]]

##### Multiple Top-Level Classes in a Single File
 - Within a `.java` file, you can *only have one top-level public class*.
 - This public class's *name must match the file name exactly*.
 - You can have *as many top-level package-private classes* with the file.
 - This means that you will have fewer files to manage.

>[! Warning] Be careful with the order in which you compile these files. Java will not be able to automatically compile the class if it is within a package-private file.

 - Even IDEs cannot understand and unpack the class files.


##### Sealed Classes
 - The `sealed` keyword is used to *limit the extendibility* of a parent class.
 - When a class is `sealed`, you must specify the names of the classes that can extend it.
 - I.e. it allows a parent class to strictly define which specific subclasses are allowed to extend it using the `permits` keyword.
 - These subclasses must certain restriction:
	 - They must be `final`, `sealed`, or `non-sealed`.
	 - As with the parent class, if the child class is `sealed`, it must also specify the classes that can extend it.
	 - However, if the subclass is `non-sealed`, no restrictions apply, but you must respect the access modifiers.
	 - As mentioned above, if the subclass is `final`, it cannot be extended at all.
 - Example:
```java
public sealed class Shape permits Circle, Rectangle { ... }
```
 - Therefore, the classes `Circle` and `Rectangle` are only allowed to extend the `Shape` class!



