[Slides](https://ele.exeter.ac.uk/pluginfile.php/5576436/mod_resource/content/1/L07-wrappers_and_strings_note_taking_form.pdf)


##### Contents
 - [[#Passing by Value]]
 - [[#Primitive Wrapper Classes]]
 - [[#Autoboxing and Unboxing]]
 - [[#The String Class]]
 - [[#Equivalence `==` vs. `.equals()`]]


##### Passing by Value
 - *All* data is *passed by value* in Java.
 - This behaviour changes depending on the data type:
 - **Primitive Arguments**:
	 - If you pass a *primitive data type* into a method, the primitive data is *copied*.
	 - Any changes to the data within the method *do not effect the original* variable.
 - **Reference Arguments (Objects)**:
	 - When you pass in an object, *the value that is copied is the reference* (*memory address*) that the variable holds.
	 - Therefore, *any changes* to the data within the method *will effect the original*.
	 - The method *cannot change the reference the original variable holds*.


##### Primitive Wrapper Classes
 - Wrapper classes wrap primitive types into an object.
 - Examples:
	 - `boolean` -> `Boolean`
	 - `int` -> `Integer`
	 - `double` -> `Double`
	 - `char` -> `Character`
 - They provide factory or utility methods, such as `Integer.parseInt();` or `Double.parseDouble();`.


##### Autoboxing and Unboxing
 - Java automatically handles the conversion between primitives and their wrapper objects to make coding easier.
 - **Autoboxing**: 
	 - Automatically convert a primitive type (like `3`) into its wrapper object (`Integer`).
	 - The process happens during assignment (`Integer b = 8;`) or when passing an `int` to a method that excepts an `Integer`.
 - **Unboxing**:
	 - This is the process of automatically converting a *wrapper object back into its primitive version*.
	 - This happens when you assign an `Integer` object to an `int` variable.


##### The String Class
 - E.g. `String name = "Cameron";`
 - **Immutability**:
	 - Once a `String` object is created, its contents can *never be changed*.
	 - Methods like `toUpperCase()` or `replace()` do not change the original string, instead, they *create and return a brand new string* with the changes.
 - **The String Pool**:
	 - Java uses a "string pool" in memory to reuse string constants.
	 - This allows Java to reuse an existing string from the pool if it already exists.
	 - Therefore, if you had two differently named `String` variables with the same string literal, they will both point to the same memory address.
	 - This saves resources and time allocating a new area of memory.
	 - You can use the `new` keyword to force a brand new memory area to be allocated, but this is not recommended.


##### Equivalence: `==` vs. `.equals()`
 - Always use `.equals()` to compare Strings, not `==`.
 - `==` Operator:
	 - Tests for reference equivalence.
	 - I.e., checks if both variables point to the same area of memory.
 - `.equals` Method:
	 - Test logical equivalence.
	 - For the `String` class, it checks if the actual characters inside the strings are identical.





